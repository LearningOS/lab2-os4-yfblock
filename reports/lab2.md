# 第四章练习

## 编程作业完成内容

1. 完成map和unmap，并自动判重
2. 在第一张的基础上添加函数对来自用户空间的地址进行转化，方便内核进行内存读写
3. 对第三章完成内容进行小幅度修改

## 问答作业

1. 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？
   答：SV39页表项组成如下:

   | Reserved | Physical Page Number | RSW  |  D   |  A   |  G   |  U   |  X   |  W   |  R   |  V   |
   | :------: | :------------------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   |  63..54  |        53..10        | 9..8 |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |

   `Reserved`为保留位

   `Physical Page Number`也称为`PPN`为物理页号

   `RSW`为`supervisor`保留位

   `D` 为 `Dirty`, 用于判断是否被修改过

   `A` 为 `Accessed`，用于判断是否被访问过

   `G` 为 `Global`，全局映射

   `U`为`User`，控制是否为用户态可访问

   `X` 为 `Executable`，控制是否可执行

   `W` 为 `Writable`，控制是否可写

   `R` 为 `Readable`，控制是否可读

   `V` 为 `Valid`, 用于判断页表项是否有效

2. 缺页

   + 缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。
     - 请问哪些异常可能是缺页导致的？
       答：缺页可能导致 `PageFault` 异常，通常由访问不存在的页产生。
     - 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。
       答：略
   + 缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是` os` 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。
     + 这样做有哪些好处？
       答：这样可以节省内存空间，有些内存被用户申请后永远都不会访问，使用`Lazy`策略可以节省系统性能。
   + 缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。
     - 此时页面失效如何表现在页表项(PTE)上？
       答：页表项的`V`位为0

3. 双页表与单页表

   + 为了防范侧信道攻击，我们的 `os` 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 [KPTI](https://en.wikipedia.org/wiki/Kernel_page-table_isolation) )
     - 在单页表情况下，如何更换页表？
       答：切换任务时进行更换。
     - 单页表情况下，如何控制用户态无法访问内核页面？
       答：对内核所拥有的页面 `U` 位置零。
     - 单页表有何优势？（回答合理即可）
       答：无需频繁的更换表，不必频繁刷新快表。
     - 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）
       答：双页表时每次特权级切换都对页表进行更换，单页表时仅在切换任务时更换页表。